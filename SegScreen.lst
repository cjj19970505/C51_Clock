C51 COMPILER V9.59.0.0   SEGSCREEN                                                         01/09/2019 16:53:21 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SEGSCREEN
OBJECT MODULE PLACED IN SegScreen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SegScreen\SegScreen.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\SegScreen.lst) TABS(2) OBJECT(SegScreen.obj)

line level    source

   1          #include "..\\Looper\\Looper.h"
   2          #include <REG51.H>
   3          #include <absacc.h>
   4          #include "SegScreen.h"
   5          #define SEGSCREEN_GET_LOOPMODE (segScreen_loop_mode)
   6          #define SEGSCREEN_SET_LOOPMODE(value) (segScreen_loop_mode = (value))
   7          #define SEGSCREEN_LOOPMODE_NOLOOP 0
   8          #define SEGSCREEN_LOOPMODE_LOOP 1
   9          #define SEGSCREEN_LOOPMODE_DURATION 300
  10          #define SEGSCREEN_LOOPMODE_ZERONUM 5
  11          //From Right To Left--0 to 7
  12          int segScreen_CurrShiftMask = 0x01;
  13          int segScreen_shiftTimer = 0;
  14          unsigned char code segScreen_led_table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00,0x08,0x40
             -,0x79  };
  15          unsigned char segScreen_led[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  16          int SegScreen_ShiftMaskToIndex(int segMask);
  17          int segScreen_temp_i;
  18          char segScreen_loop_mode = 0;
  19          int segScreen_Loop_timer = 0;
  20          char *segScreenStrToPrint = 0;
  21          char segScreenStrInScreen[17];
  22          char segScreenLoopModeCurrIndex = 0;
  23          void SegScreen_LooperUpdate(LOOPER *looper)
  24          {
  25   1        int segIndex = 0;
  26   1        int strLength = 0;
  27   1        segScreen_shiftTimer += looper->deltaTime;
  28   1        XBYTE[0x9000]= segScreen_led[SegScreen_ShiftMaskToIndex(segScreen_CurrShiftMask)];
  29   1        XBYTE[0x8000]= segScreen_CurrShiftMask;
  30   1        /*
  31   1        if(segScreenStrToPrint != 0)
  32   1        {
  33   1          segScreen_temp_i = 0;
  34   1          while(segScreenStrToPrint[segScreen_temp_i] != '\0')
  35   1          {
  36   1            segScreen_temp_i++;
  37   1          }
  38   1          strLength = segScreen_temp_i;
  39   1          for(segScreen_temp_i = 0; segScreen_temp_i < 16; segScreen_temp_i++)
  40   1          {
  41   1            if(((segScreen_temp_i + segScreenLoopModeCurrIndex) % (strLength + SEGSCREEN_LOOPMODE_ZERONUM)) >= strL
             -ength)
  42   1            {
  43   1              segScreenStrInScreen[segScreen_temp_i] = '1';
  44   1            }
  45   1            else
  46   1            {
  47   1              segScreenStrInScreen[segScreen_temp_i] = segScreenStrToPrint[((segScreen_temp_i + segScreenLoopModeCur
             -rIndex) % (strLength + SEGSCREEN_LOOPMODE_ZERONUM))];
  48   1            }
  49   1          }
  50   1          segScreenStrInScreen[16] = '\0';
  51   1        }
C51 COMPILER V9.59.0.0   SEGSCREEN                                                         01/09/2019 16:53:21 PAGE 2   

  52   1        */
  53   1        /*
  54   1        for(segScreen_temp_i = 0; segScreenStrToPrint[segScreen_temp_i] != '\0'; segScreen_temp_i++)
  55   1        {
  56   1          segScreenStrInScreen[segScreen_temp_i] = segScreenStrToPrint[segScreen_temp_i];
  57   1          
  58   1        }*/
  59   1        for(segScreen_temp_i = 0; segScreen_temp_i < 16; segScreen_temp_i = 0)
  60   1        {
  61   2          segScreenStrInScreen[segScreen_temp_i] = '1';
  62   2        }
  63   1        segScreenStrInScreen[16] = '\0';
  64   1        
  65   1        segIndex = 7;
  66   1        for(segScreen_temp_i = 0; segScreen_temp_i < 8; segScreen_temp_i++)
  67   1        {
  68   2          segScreenStrInScreen[segScreen_temp_i] = segScreenStrToPrint[segScreen_temp_i];
  69   2        }
  70   1        for(segScreen_temp_i = 0; segScreenStrInScreen[segScreen_temp_i] != '\0' && segIndex >= 0; segScreen_temp
             -_i++)
  71   1        {
  72   2          if(segScreenStrInScreen[segScreen_temp_i] == '.')
  73   2          {
  74   3            segScreen_led[segIndex+1] = segScreen_led[segIndex+1] | 0x80;
  75   3          }
  76   2          else
  77   2          {
  78   3            if(segScreenStrInScreen[segScreen_temp_i] == ' ' )
  79   3            {
  80   4              segScreen_led[segIndex] = 0;
  81   4            }
  82   3            else if(segScreenStrInScreen[segScreen_temp_i] >= '0' && segScreenStrInScreen[segScreen_temp_i] <= '9')
  83   3            {
  84   4              segScreen_led[segIndex] = segScreen_led_table[segScreenStrInScreen[segScreen_temp_i] - '0'];
  85   4            }
  86   3            segIndex--;
  87   3          }
  88   2        }
  89   1        
  90   1        
  91   1        
  92   1        if(segScreen_shiftTimer >= SEGSCREEN_SHIFT_INTERVAL_MS)
  93   1        {
  94   2          segScreen_shiftTimer = 0;
  95   2          segScreen_CurrShiftMask = 0xFF & (segScreen_CurrShiftMask << 1);
  96   2          if(segScreen_CurrShiftMask == 0)
  97   2          {
  98   3            segScreen_CurrShiftMask = 0x01;
  99   3          }
 100   2        }
 101   1      }
 102          /*
 103          void SegScreen_Print_Int(int value)
 104          {
 105            int temp;
 106            for(segScreen_temp_i = 0; segScreen_temp_i < 8; segScreen_temp_i++)
 107            {
 108              segScreen_led[segScreen_temp_i] = 0x00;
 109            }
 110            temp = value < 0 ? -value : value;
 111            segScreen_temp_i = 0;
 112            if(value == 0)
C51 COMPILER V9.59.0.0   SEGSCREEN                                                         01/09/2019 16:53:21 PAGE 3   

 113            {
 114              segScreen_led[0] = segScreen_led_table[0];
 115            }
 116            else
 117            {
 118              while(temp != 0 && segScreen_temp_i < 8)
 119              {
 120                segScreen_led[segScreen_temp_i] = segScreen_led_table[temp % 10];
 121                temp = temp / 10;
 122                segScreen_temp_i++;
 123              }
 124            }
 125            
 126            if(segScreen_temp_i < 8 && value < 0)
 127            {
 128              segScreen_led[segScreen_temp_i] = 0x40;
 129            }
 130          }
 131          */
 132          /*
 133          void SegScreen_Print_Bin(int value)
 134          {
 135            for(segScreen_temp_i == 0; segScreen_temp_i < 8; segScreen_temp_i++)
 136            {
 137              segScreen_led[segScreen_temp_i] = segScreen_led_table[(value & 1<<segScreen_temp_i) == 0 ? 0: 1];
 138            }
 139          }*/
 140          
 141          //Can only show dot(.) and number(0..9)
 142          void SegScreen_Print_String(char *str)
 143          {
 144   1        /*
 145   1        int segIndex = 7;
 146   1        for(segScreen_temp_i = 0; segScreen_temp_i < 8; segScreen_temp_i++)
 147   1        {
 148   1          segScreen_led[segScreen_temp_i] = 0x00;
 149   1        }*/
 150   1        segScreenStrToPrint = str;
 151   1        /*
 152   1        for(segScreen_temp_i = 0; str[segScreen_temp_i] != '\0' && segIndex >= 0; segScreen_temp_i++)
 153   1        {
 154   1          if(str[segScreen_temp_i] == '.')
 155   1          {
 156   1            segScreen_led[segIndex+1] = segScreen_led[segIndex+1] | 0x80;
 157   1          }
 158   1          else
 159   1          {
 160   1            if(str[segScreen_temp_i] == ' ' )
 161   1            {
 162   1              
 163   1            }
 164   1            else if(str[segScreen_temp_i] >= '0' && str[segScreen_temp_i] <= '9')
 165   1            {
 166   1              segScreen_led[segIndex] = segScreen_led_table[str[segScreen_temp_i] - '0'];
 167   1            }
 168   1            
 169   1            segIndex--;
 170   1          }
 171   1        }*/
 172   1      }
 173          int SegScreen_ShiftMaskToIndex(int segMask){
 174   1        for(segScreen_temp_i = 0; segScreen_temp_i < 8; segScreen_temp_i++)
C51 COMPILER V9.59.0.0   SEGSCREEN                                                         01/09/2019 16:53:21 PAGE 4   

 175   1        {
 176   2          if((segMask & (1 << segScreen_temp_i)) != 0)
 177   2          {
 178   3            return segScreen_temp_i;
 179   3          }
 180   2        }
 181   1        return -1;
 182   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    364    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
